WEEK 05

Lecture 02 - Simple Aggregation Example

			PRODUCTS

NAME | CATEGORY | MANUFACTURER | PRICE
--------------------------------------
ipad | 	tablet	|	apple	   | 499
nexus| cellphone|	samsung	   | 350

SQL:

	SELECT manufacturer, COUNT(*) FROM PRODUCTS GROUP BY manufecturer;

MONGODB:

	db.products.aggregate([
		{$group:
			{
				_id:"$manufacturer",
				num_products:{$sum:1}
			}
		}
	]);

-----------------------------------------------------------------------------------

Lecture 03 - The Aggregation Pipeline

Stages in the aggregation pipeline:

Match
Group
Skip
Limit
Sort
Project
Unwind

-----------------------------------------------------------------------------------

Lecture 04 - Simple Example Expanded

QUIZ:  If you have the following collection of stuff:

	> db.stuff.find()
		{ "_id" : ObjectId("50b26f9d80a78af03b5163c8"), "a" : 1, "b" : 1, "c" : 1 }
		{ "_id" : ObjectId("50b26fb480a78af03b5163c9"), "a" : 2, "b" : 2, "c" : 1 }
		{ "_id" : ObjectId("50b26fbf80a78af03b5163ca"), "a" : 3, "b" : 3, "c" : 1 }
		{ "_id" : ObjectId("50b26fcd80a78af03b5163cb"), "a" : 3, "b" : 3, "c" : 2 }
		{ "_id" : ObjectId("50b26fd380a78af03b5163cc"), "a" : 3, "b" : 5, "c" : 3 }

and you perform the following aggregation:
	> db.stuff.aggregate([{$group:{_id:'$c'}}]);

How many documents will be in the result set from aggregate?

1
2
3 √ - pq os 3 primeiros registro (1) estaram no mesmo grupo
4
5

-----------------------------------------------------------------------------------

Lecture 05 - Compound Groupings

SQL:
	SELECT manufacturer, category, COUNT(*) FROM PRODUCTS GROUP BY manufacturer, category;

MONGODB:
	db.products.aggregate([
		{$group:
			{
				_id:{
					"manufacturer":"$manufacturer", 
					"category":"$category"
				num_products:{$sum:1}
			}
		}
	]);

QUIZ: Given the following collection:
	> db.stuff.find()
		{ "_id" : ObjectId("50b26f9d80a78af03b5163c8"), "a" : 1, "b" : 1, "c" : 1 }
		{ "_id" : ObjectId("50b26fb480a78af03b5163c9"), "a" : 2, "b" : 2, "c" : 1 }
		{ "_id" : ObjectId("50b26fbf80a78af03b5163ca"), "a" : 3, "b" : 3, "c" : 1 }
		{ "_id" : ObjectId("50b26fcd80a78af03b5163cb"), "a" : 3, "b" : 3, "c" : 2 }
		{ "_id" : ObjectId("50b26fd380a78af03b5163cc"), "a" : 3, "b" : 5, "c" : 3 }
		{ "_id" : ObjectId("50b27f7080a78af03b5163cd"), "a" : 3, "b" : 3, "c" : 2 }

And the following aggregation query:
	> db.stuff.aggregate([{$group:
		{_id:
			{'moe':'$a', 
				'larry':'$b',
				'curly':'$c'
			}
		}
	}])

How many documents will be in the result set?

2
3
4
5 √ - O quinto registro será agrupado na qtdade de 2
6

-----------------------------------------------------------------------------------

Lecture 06 - Using a document for _id

ID pode ser composto, UNIQUE - db.collection.insert({_id:{name:"Laisson",class:"m101"}, hometown:"SC"});
error se add outro registro como mesmo ID

-----------------------------------------------------------------------------------

Lecture 07 - Aggregation Expressions

$group
	- $sum: soma dos valores de uma chave me todos os documentos
	- $avg: média dos valores de uma chave me todos os documentos
	- $min: encontrar o valor mínimo de uma determinada chave
	- $max: encontrar o valor máximo de uma determinada chave
	 		|$push: adiciona valor ao array
	--array-|
	 		|$addToSet: adiciona se não existir
$sort
	- $first
	- $last

-----------------------------------------------------------------------------------

Lecture 08 - $sum

	SQL:
		SELECT manufacturer, SUM(price) FROM PRODUCTS GROUP BY manufacturer;

	MONGODB: 
		db.products.aggregate([
			{ $group:{
					_id: {
							"maker":"$manufacturer"
						},
					sum_prices:{
							$sum:"$price"
						}
				}
			}
		]);

	QUIZ: 
		Write an aggregation query to sum up the population (pop) by state and put the result in a field called population. Don't use a compound _id key (you don't need one and the quiz checker is not expecting one). The collection name is zips. so something along the lines of db.zips.aggregate...

		R: db.zips.aggregate([{$group:{'_id':'$state', population:{'$sum':'$pop'}}}]);

-----------------------------------------------------------------------------------

Lecture 09 - $avg

	SQL:
		SELECT category, AVG(price) FROM PRODUCTS GROUP BY category;

	MONGODB:
		db.products.aggregate([
			{ $group:{
					_id: {
							"category":"$category"
						},
					avg_price:{
							$avg:"$price"
						}
				}
			}
		]);

	QUIZ:
		Given population data by zip code (postal code), write an aggregation expression to calculate the average population of a zip code (postal code) by state. This dataset only contains four states, and only 50 zip codes per state, because some browsers have trouble working with large data sets.

		R: db.zips.aggregate([{$group:{'_id':'$state', population:{'$avg':'$pop'}}}]);

-----------------------------------------------------------------------------------

Lecture 10 - $addToSet

	MONGO: 
		db.products.aggregate([
			{ $group:{
					_id: {
							"marker":"$manufacturer"
						},
					categories:{
							$addToSet:"$category"
						}
				}
			}
		])

	QUIZ: 
		Again the collection will be called zips. You can deduce what your result column names should be from the above output. (ignore the issue that a city may have the same name in two different states and is in fact two different cities in that case - for eg Springfield, MO and Springfield, MA)

		R: db.zips.aggregate([{$group:{"_id":"$city", "postal_codes":{"$addToSet":"$_id"}}}]);

-----------------------------------------------------------------------------------

Lecture 11 - $push

	MONGO:
		 db.products.aggregate([
			{ $group:{
					_id: {
							"marker":"$manufacturer"
						},
					categories:{
							$push:"$category"
						}
				}
			}
		]);

	QUIZ: 
		Given the zipcode dataset (explained more fully in the using $sum quiz) that has documents that look like this:
		> db.zips.findOne()
			{
				"city" : "ACMAR",
				"loc" : [
					-86.51557,
					33.584132
				],
				"pop" : 6055,
				"state" : "AL",
				"_id" : "35004"
			}

		would you expect the following two queries to produce the same result or different results?
			db.zips.aggregate([{"$group":{"_id":"$city", "postal_codes":{"$push":"$_id"}}}])
			db.zips.aggregate([{"$group":{"_id":"$city", "postal_codes":{"$addToSet":"$_id"}}}])

		- Same result √ - porque o _id é único, não vai repetir
		- Different Result

-----------------------------------------------------------------------------------

Lecture 12 - $max and $min

	MONGO:
		 db.products.aggregate([
			{ $group:{
					_id: {
							"marker":"$manufacturer"
						},
					maxprice:{
							$max:"$price"
						}
				}
			}
		]);

	SQL:
		SELECT manufacturer, MAX(price) FROM PRODUCTS GROUP BY manufacturer;

	MONGO:
		 db.products.aggregate([
			{ $group:{
					_id: {
							"marker":"$manufacturer"
						},
					maxprice:{
							$min:"$price"
						}
				}
			}
		]);

	SQL:
		SELECT manufacturer, MIN(price) FROM PRODUCTS GROUP BY manufacturer;

-----------------------------------------------------------------------------------

Lecture 13 - $group stages

	Single group

		MONGO:
			db.grades.aggregate([  
			    {  
			        '$group':{  
			            _id:{  
			                class_id:"$class_id",
			                student_id:"$student_id"
			            },
			            'average':{  
			                "$avg":"$score"
			            }
			        }
			    }
			])

	Double group

		MONGO:
			db.grades.aggregate([  
			    {  
			        '$group':{  
			            _id:{  
			                class_id:"$class_id",
			                student_id:"$student_id"
			            },
			            'average':{  
			                "$avg":"$score"
			            }
			        }
			    },
			    {  
			        '$group':{  
			            _id:"$_id.class_id",
			            'average':{  
			                "$avg":"$average"
			            }
			        }
			    }
			]);

	QUIZ:
		Given the following collection:
		> db.fun.find()
			{ "_id" : 0, "a" : 0, "b" : 0, "c" : 21 }
			{ "_id" : 1, "a" : 0, "b" : 0, "c" : 54 }
			{ "_id" : 2, "a" : 0, "b" : 1, "c" : 52 }
			{ "_id" : 3, "a" : 0, "b" : 1, "c" : 17 }
			{ "_id" : 4, "a" : 1, "b" : 0, "c" : 22 }
			{ "_id" : 5, "a" : 1, "b" : 0, "c" : 5 }
			{ "_id" : 6, "a" : 1, "b" : 1, "c" : 87 }
			{ "_id" : 7, "a" : 1, "b" : 1, "c" : 97 }

		And the following aggregation query
		db.fun.aggregate([{$group:{_id:{a:"$a", b:"$b"}, c:{$max:"$c"}}}, {$group:{_id:"$_id.a", c:{$min:"$c"}}}]);
		What values are returned?

		R:
			17 and 54
			97 and 21
			54 and 5
			52 and 22 - √: no primeiro agrupamento vai pegar o maior de 'C' (0,0=54),(0,1=52),(1,0=22),(1,1=97)
						   no segundo agrupamento vai pegar o menor de cada grupo (0=52,54) e (1=22,97)
						   pegando o menor de 0=52 e 1=22
						   { "_id" : 0, "c" : 52 }
						   { "_id" : 1, "c" : 22 }

-----------------------------------------------------------------------------------

Lecture 14 - $project

- remove keys
- add new keys
- restore keys
- use some simple functions on keys
	- $toUpper
	- $toLower
	- $add
	- $multiply

	MONGO:
		db.products.aggregate([  
		    {  
		        $project:{  
		            _id:0,
		            'maker':{  
		                $toLower:"$manufacturer"
		            },
		            'details':{  
		                'category':"$category",
		                'price':{  
		                    "$multiply":[  
		                        "$price",
		                        10
		                    ]
		                }
		            },
		            'item':'$name'
		        }
		    }
		]);

	QUIZ:
		Write an aggregation query with a single projection stage that will transform the documents in the zips collection from this:
			{
				"city" : "ACMAR",
				"loc" : [
					-86.51557,
					33.584132
				],
				"pop" : 6055,
				"state" : "AL",
				"_id" : "35004"
			}

		to documents in the result set that look like this:
			{
				"city" : "acmar",
				"pop" : 6055,
				"state" : "AL",
				"zip" : "35004"
			}
		So that the checker works properly, please specify what you want to do with the _id key as the first item. The other items should be ordered as above. As before, assume the collection is called zips. You are running only the projection part of the pipeline for this quiz.

		R:
			db.zips.aggregate([  
			    {  
			        $project:{  
			            _id:0,
			            'city':{  
			                $toLower:'$city'
			            },
			            pop:1,
			            state:1,
			            'zip':'$_id'
			        }
			    }
			]);

-----------------------------------------------------------------------------------

Lecture 15 - $match

	MONGO:
		db.zips.aggregate([  
		    {  
		        $match:{  
		            state:"NY"
		        }
		    },
		    {  
		        $group:{  
		            _id:"$city",
		            population:{  
		                $sum:"$pop"
		            },
		            zip_codes:{  
		                $addToSet:"$_id"
		            }
		        }
		    },
		    {  
		        $project:{  
		            _id:0,
		            city:"$_id",
		            population:1,
		            zip_codes:1
		        }
		    }
		]);

	QUIZ:
		Again, thinking about the zipcode collection, write an aggregation query with a single match phase that filters for zipcodes with greater than 100,000 people.

		R:
			db.zips.aggregate([  
			    {  
			        $match:{  
			            pop:{  
			                $gt:100000
			            }
			        }
			    }
			]);

-----------------------------------------------------------------------------------

Lecture 16 - $sort

- disk and memory based: 100mb
- before or after the grouping stage
	
	MONGO:
		db.zips.aggregate([
		    {
		        $match:{
		            state:"NY"
		        }
		    },
		    {
		        $group:{
		            _id:"$city",
		            population:{
		                $sum:"$pop"
		            },

		        }
		    },
		    {
		        $project:{
		            _id:0,
		            city:"$_id",
		            population:1,

		        }
		    },
		    {
		        $sort:{
		            population:-1
		        }
		    }
		]);

	QUIZ:
		Again, considering the zipcode collection, which has documents that look like this,
		{
			"city" : "ACMAR",
			"loc" : [
				-86.51557,
				33.584132
			],
			"pop" : 6055,
			"state" : "AL",
			"_id" : "35004"
		}

		Write an aggregation query with just a sort stage to sort by (state, city), both ascending. Assume the collection is called zips.

		R:
			db.zips.aggregate([
			    {
			        $sort:{
			            state:1,
			            city:1
			        }
			    }
			]);

-----------------------------------------------------------------------------------

Lecture 17 - $limit and $skip

first $skip and second $limit, but after of $sort

	MONGO:
		db.zips.aggregate([
		    {
		        $match:{
		            state:"NY"
		        }
		    },
		    {
		        $group:{
		            _id:"$city",
		            population:{
		                $sum:"$pop"
		            },

		        }
		    },
		    {
		        $project:{
		            _id:0,
		            city:"$_id",
		            population:1,

		        }
		    },
		    {
		        $sort:{
		            population:-1
		        }
		    },
		    {
		        $skip:10
		    },
		    {
		        $limit:5
		    }
		]);

	QUIZ:
		Suppose you change the order of skip and limit in the query shown in the lesson, to look like this:
			
			db.zips.aggregate([
			    {
			        $match:{
			            state:"NY"
			        }
			    },
			    {
			        $group:{
			            _id:"$city",
			            population:{
			                $sum:"$pop"
			            },

			        }
			    },
			    {
			        $project:{
			            _id:0,
			            city:"$_id",
			            population:1,

			        }
			    },
			    {
			        $sort:{
			            population:-1
			        }
			    },
			    {
			        $limit:5
			    },
			    {
			        $skip:10
			    }
			]);

			How many documents do you think will be in the result set?

				10
				5
				0 √: pq trouxe somente 5 registro e depois pulou 10 registro, chegando ao 0
				100
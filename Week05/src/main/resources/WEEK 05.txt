WEEK 05

Lecture 02 - Simple Aggregation Example

			PRODUCTS

NAME | CATEGORY | MANUFACTURER | PRICE
--------------------------------------
ipad | 	tablet	|	apple	   | 499
nexus| cellphone|	samsung	   | 350

SQL:

	SELECT manufacturer, COUNT(*) FROM PRODUCTS GROUP BY manufecturer;

MONGODB:

	db.products.aggregate([
		{$group:
			{
				_id:"$manufacturer",
				num_products:{$sum:1}
			}
		}
	]);

-----------------------------------------------------------------------------------

Lecture 03 - The Aggregation Pipeline

Stages in the aggregation pipeline:

Match
Group
Skip
Limit
Sort
Project
Unwind

-----------------------------------------------------------------------------------

Lecture 04 - Simple Example Expanded

QUIZ:  If you have the following collection of stuff:

	> db.stuff.find()
		{ "_id" : ObjectId("50b26f9d80a78af03b5163c8"), "a" : 1, "b" : 1, "c" : 1 }
		{ "_id" : ObjectId("50b26fb480a78af03b5163c9"), "a" : 2, "b" : 2, "c" : 1 }
		{ "_id" : ObjectId("50b26fbf80a78af03b5163ca"), "a" : 3, "b" : 3, "c" : 1 }
		{ "_id" : ObjectId("50b26fcd80a78af03b5163cb"), "a" : 3, "b" : 3, "c" : 2 }
		{ "_id" : ObjectId("50b26fd380a78af03b5163cc"), "a" : 3, "b" : 5, "c" : 3 }

and you perform the following aggregation:
	> db.stuff.aggregate([{$group:{_id:'$c'}}]);

How many documents will be in the result set from aggregate?

1
2
3 √ - pq os 3 primeiros registro (1) estaram no mesmo grupo
4
5

-----------------------------------------------------------------------------------

Lecture 05 - Compound Groupings

SQL:
	SELECT manufacturer, category, COUNT(*) FROM PRODUCTS GROUP BY manufacturer, category;

MONGODB:	
	db.products.aggregate([
		{$group:
			{
				_id:{
					"manufacturer":"$manufacturer", 
					"category":"$category"
				num_products:{$sum:1}
			}
		}
	]);

QUIZ: Given the following collection:
	> db.stuff.find()
		{ "_id" : ObjectId("50b26f9d80a78af03b5163c8"), "a" : 1, "b" : 1, "c" : 1 }
		{ "_id" : ObjectId("50b26fb480a78af03b5163c9"), "a" : 2, "b" : 2, "c" : 1 }
		{ "_id" : ObjectId("50b26fbf80a78af03b5163ca"), "a" : 3, "b" : 3, "c" : 1 }
		{ "_id" : ObjectId("50b26fcd80a78af03b5163cb"), "a" : 3, "b" : 3, "c" : 2 }
		{ "_id" : ObjectId("50b26fd380a78af03b5163cc"), "a" : 3, "b" : 5, "c" : 3 }
		{ "_id" : ObjectId("50b27f7080a78af03b5163cd"), "a" : 3, "b" : 3, "c" : 2 }

And the following aggregation query:
	> db.stuff.aggregate([{$group:
		{_id:
			{'moe':'$a', 
				'larry':'$b',
				'curly':'$c'
			}
		}
	}])

How many documents will be in the result set?

2
3
4
5 √ - O quinto registro será agrupado na qtdade de 2
6

-----------------------------------------------------------------------------------

Lecture 06 - Using a document for _id

ID pode ser composto, UNIQUE - db.collection.insert({_id:{name:"Laisson",class:"m101"}, hometown:"SC"});
error se add outro registro como mesmo ID

-----------------------------------------------------------------------------------

Lecture 07 - Aggregation Expressions

$group
	- $sum: soma dos valores de uma chave me todos os documentos
	- $avg: média dos valores de uma chave me todos os documentos
	- $min: encontrar o valor mínimo de uma determinada chave
	- $max: encontrar o valor máximo de uma determinada chave
	 		|$push: adiciona valor ao array
	--array-|
	 		|$addToSet: adiciona se não existir
$sort
	- $first
	- $last

-----------------------------------------------------------------------------------

Lecture 08 - $sum

	SQL:
		SELECT manufacturer, SUM(price) FROM PRODUCTS GROUP BY manufacturer;

	MONGODB: 
		db.products.aggregate([
			{ $group:{
					_id: {
							"maker":"$manufacturer"
						},
					sum_prices:{
							$sum:"$price"
						}
				}
			}
		]);

	QUIZ: 
		Write an aggregation query to sum up the population (pop) by state and put the result in a field called population. Don't use a compound _id key (you don't need one and the quiz checker is not expecting one). The collection name is zips. so something along the lines of db.zips.aggregate...

		R: db.zips.aggregate([{$group:{'_id':'$state', population:{'$sum':'$pop'}}}]);

-----------------------------------------------------------------------------------

Lecture 09 - $avg

	SQL:
		SELECT category, AVG(price) FROM PRODUCTS GROUP BY category;

	MONGODB:
		db.products.aggregate([
			{ $group:{
					_id: {
							"category":"$category"
						},
					avg_price:{
							$avg:"$price"
						}
				}
			}
		]);

	QUIZ:
		Given population data by zip code (postal code), write an aggregation expression to calculate the average population of a zip code (postal code) by state. This dataset only contains four states, and only 50 zip codes per state, because some browsers have trouble working with large data sets.

		R: db.zips.aggregate([{$group:{'_id':'$state', population:{'$avg':'$pop'}}}]);

-----------------------------------------------------------------------------------

Lecture 10 - $addToSet

	MONGO: 
		db.products.aggregate([
			{ $group:{
					_id: {
							"marker":"$manufacturer"
						},
					categories:{
							$addToSet:"$category"
						}
				}
			}
		])

	QUIZ: 
		Again the collection will be called zips. You can deduce what your result column names should be from the above output. (ignore the issue that a city may have the same name in two different states and is in fact two different cities in that case - for eg Springfield, MO and Springfield, MA)

		R: db.zips.aggregate([{$group:{"_id":"$city", "postal_codes":{"$addToSet":"$_id"}}}]);

-----------------------------------------------------------------------------------

Lecture 11 - $push

	MONGO:
		 db.products.aggregate([
			{ $group:{
					_id: {
							"marker":"$manufacturer"
						},
					categories:{
							$push:"$category"
						}
				}
			}
		]);

	QUIZ: 
		Given the zipcode dataset (explained more fully in the using $sum quiz) that has documents that look like this:
		> db.zips.findOne()
			{
				"city" : "ACMAR",
				"loc" : [
					-86.51557,
					33.584132
				],
				"pop" : 6055,
				"state" : "AL",
				"_id" : "35004"
			}

		would you expect the following two queries to produce the same result or different results?
			db.zips.aggregate([{"$group":{"_id":"$city", "postal_codes":{"$push":"$_id"}}}])
			db.zips.aggregate([{"$group":{"_id":"$city", "postal_codes":{"$addToSet":"$_id"}}}])

		- Same result √ - porque o _id é único, não vai repetir
		- Different Result

-----------------------------------------------------------------------------------

Lecture 12 - $max and $min

	MONGO:
		 db.products.aggregate([
			{ $group:{
					_id: {
							"marker":"$manufacturer"
						},
					maxprice:{
							$max:"$price"
						}
				}
			}
		]);

	SQL:
		SELECT manufacturer, MAX(price) FROM PRODUCTS GROUP BY manufacturer;

	MONGO:
		 db.products.aggregate([
			{ $group:{
					_id: {
							"marker":"$manufacturer"
						},
					maxprice:{
							$min:"$price"
						}
				}
			}
		]);

	SQL:
		SELECT manufacturer, MIN(price) FROM PRODUCTS GROUP BY manufacturer;		

-----------------------------------------------------------------------------------

Lecture 13 - $group stages

	Single group

		MONGO:
			db.grades.aggregate([  
			    {  
			        '$group':{  
			            _id:{  
			                class_id:"$class_id",
			                student_id:"$student_id"
			            },
			            'average':{  
			                "$avg":"$score"
			            }
			        }
			    }
			])

	Double group

		MONGO:
			db.grades.aggregate([  
			    {  
			        '$group':{  
			            _id:{  
			                class_id:"$class_id",
			                student_id:"$student_id"
			            },
			            'average':{  
			                "$avg":"$score"
			            }
			        }
			    },
			    {  
			        '$group':{  
			            _id:"$_id.class_id",
			            'average':{  
			                "$avg":"$average"
			            }
			        }
			    }
			]);

	QUIZ:
		Given the following collection:
		> db.fun.find()
			{ "_id" : 0, "a" : 0, "b" : 0, "c" : 21 }
			{ "_id" : 1, "a" : 0, "b" : 0, "c" : 54 }
			{ "_id" : 2, "a" : 0, "b" : 1, "c" : 52 }
			{ "_id" : 3, "a" : 0, "b" : 1, "c" : 17 }
			{ "_id" : 4, "a" : 1, "b" : 0, "c" : 22 }
			{ "_id" : 5, "a" : 1, "b" : 0, "c" : 5 }
			{ "_id" : 6, "a" : 1, "b" : 1, "c" : 87 }
			{ "_id" : 7, "a" : 1, "b" : 1, "c" : 97 }

		And the following aggregation query
		db.fun.aggregate([{$group:{_id:{a:"$a", b:"$b"}, c:{$max:"$c"}}}, {$group:{_id:"$_id.a", c:{$min:"$c"}}}]);
		What values are returned?

		R:
			17 and 54
			97 and 21
			54 and 5
			52 and 22 - √: no primeiro agrupamento vai pegar o maior de 'C' (0,0=54),(0,1=52),(1,0=22),(1,1=97)
						   no segundo agrupamento vai pegar o menor de cada grupo (0=52,54) e (1=22,97)
						   pegando o menor de 0=52 e 1=22
						   { "_id" : 0, "c" : 52 }
						   { "_id" : 1, "c" : 22 }

-----------------------------------------------------------------------------------
